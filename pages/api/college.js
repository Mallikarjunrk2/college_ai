// pages/api/faq.js
import supabase from "../../lib/supabase";

/**
 * Simple FAQ lookup API.
 * Expects: POST { question: "..." }
 * Looks for the best simple text match in the `college_faq` table and returns answer.
 *
 * Table schema suggestion:
 *   create table college_faq (
 *     id bigint generated by default as identity primary key,
 *     question text not null,
 *     answer text not null
 *   );
 */

function normalize(s = "") {
  return s.trim().toLowerCase();
}

export default async function handler(req, res) {
  if (req.method !== "POST") return res.status(405).json({ message: "Method not allowed" });

  const question = (req.body?.question || "").trim();
  if (!question) return res.status(400).json({ message: "Missing question" });

  try {
    const { data, error } = await supabase
      .from("college_faq")
      .select("id, question, answer");

    if (error) {
      console.error("faq select error:", error);
      return res.status(500).json({ message: "Database error" });
    }

    if (!data || data.length === 0) {
      return res.status(200).json({ reply: "" });
    }

    // Basic best-match heuristic:
    // 1) exact substring match (longest matched question wins)
    // 2) fallback to highest intersection of words
    const qNorm = normalize(question);

    let best = null;
    let bestScore = -1;

    for (const row of data) {
      const qRow = normalize(row.question);
      let score = 0;

      if (qNorm === qRow) {
        score = 1000; // exact
      } else if (qNorm.includes(qRow) || qRow.includes(qNorm)) {
        score = qRow.length + 100; // substring
      } else {
        // word intersection
        const qWords = new Set(qNorm.split(/\W+/).filter(Boolean));
        const rowWords = new Set(qRow.split(/\W+/).filter(Boolean));
        let common = 0;
        for (const w of qWords) if (rowWords.has(w)) common++;
        score = common;
      }

      if (score > bestScore) {
        bestScore = score;
        best = row;
      }
    }

    // threshold â€” if no decent match, return empty so frontend falls back to /api/chat
    const SCORE_THRESHOLD = 1;
    if (!best || bestScore < SCORE_THRESHOLD) {
      return res.status(200).json({ reply: "" });
    }

    return res.status(200).json({ reply: best.answer, matchedQuestion: best.question });
  } catch (e) {
    console.error("faq handler error:", e);
    return res.status(500).json({ message: "Server error" });
  }
}
